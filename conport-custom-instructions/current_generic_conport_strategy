# --- ConPort Memory Strategy (Compact) ---
conport_memory_strategy:
  # CRITICAL: At the beginning of every session, the agent MUST execute the 'initialization' sequence
  # to determine the ConPort status and load relevant context.
  mcp_server_name: "conport-aimed"
  workspace_id_source: "The agent must obtain the absolute path to the current workspace to use as `workspace_id` for all ConPort tool calls. This might be available as `${workspaceFolder}` or require asking the user."
  
  # Keep responses prefixed and always include workspace_id in tool calls.
  rules:
    - "Prefix every response with [CONPORT_ACTIVE] or [CONPORT_INACTIVE]."
    - "workspace_id: absolute path of current workspace. Ask user if unknown."
    - "You MUST complete steps 1→2→3→4 in exact sequence unless user says it's not required. No exceptions."
    
  # 1) Initialization (improved flow with folder check first)
  initialization:
    agent_action_plan:
      - step: 1
        do: "Determine ACTUAL_WORKSPACE_ID."
      - step: 2
        do: "List ACTUAL_WORKSPACE_ID + '/context_portal_aimed/' to check folder exists."
      - step: 3
        branch:
          - if: "context_portal_aimed folder exists"
            then: "proceed_to_ui_launch_question"
          - else: "context_portal_aimed folder NOT found"
            then: "handle_conport_initialization_first"

  # 2) Handle initialization when folder doesn't exist
  handle_conport_initialization_first:
    do:
      - "Tell user: 'ConPort folder not found. Initializing ConPort for this workspace...'"
      - "Initialize ConPort by making first ConPort tool call (e.g., get_product_context) to trigger database creation."
      - "List context_portal_aimed folder again to verify creation."
      - branch:
          - if: "Database creation successful (folder and context_aimed.db file exist)"
            then: "Tell user: 'ConPort successfully initialized.' → proceed_to_ui_launch_question"
          - else: "Database creation failed"
            then: "Tell user: 'ConPort initialization failed.' → Set [CONPORT_INACTIVE]."

  # 3) UI Launch question (only after ConPort is verified to exist)
  proceed_to_ui_launch_question:
    do:
      - ask: "ConPort is ready! Would you like me to launch the AIMED UI dashboard for visual project management?"
        options:
          - "Yes, launch the UI" → execute_command: "python ./context_portal_aimed/portal_launcher.py"; monitor output; provide link when ready → proceed to context_loading
          - "No, it is already open" → Set status [CONPORT_ACTIVE]; proceed to context_loading with "After I create a todo list I'll log it as a Progress item"
          - "No, continue with chat only" → proceed to context_loading
      - branch:
          - if: "context_aimed.db exists"
            then: "load_existing_context"
          - else: "context_aimed.db missing"
            then: "setup_new_database"

  # 4) Load existing context
  load_existing_context:
    do:
      - "get_product_context → store"
      - "get_active_context → store"
      - "get_decisions(limit:5) → store"
      - "get_progress(limit:5) → store"
      - "get_system_patterns(limit:5) → store"
      - "get_custom_data(category:'critical_settings') → store"
      - "get_custom_data(category:'ProjectGlossary') → store"
      - "get_recent_activity_summary(limit_per_type:3) → store"
      - "Set status [CONPORT_ACTIVE]. Tell user contexts loaded; offer: review recent, continue, or new task."

  # 5) Setup new database
  setup_new_database:
    do:
      - "Tell user no existing DB found. Ask to initialize now."
      - "If yes: optional bootstrap: list root → if 'projectBrief.md' found, read; ask to import into product context; on yes: update_product_context(content:{initial_product_brief: ...})."
      - "Proceed to load_existing_context sequence."

 if_conport_already_open:
   do: "Set [CONPORT_ACTIVE]. Tell user: 'After I create a todo list I'll log it as a Progress item.'"

 proactive_linking_policy:
   rule: "ALWAYS propose linking new entries (except if first entry) to related items."
   trigger: "After logging any decision, progress, active_context, pattern, custom_data or glossary."
   relationship_types: ["blocked_by", "builds_on", "clarifies", "consumes", "depends_on", "derived_from", "documented_in", "implements", "produces", "related_to", "resolves", "tracks", "verifies"]
   process:
     - "Identify potential related existing items from conversation context."
     - "Propose link with ask_followup_question: 'Should I link [new item] to [existing item] with relationship [suggested_type]?'"
     - "On confirmation: call link_conport_items."

  # 2) General norms (concise)
  general:
    - "Status prefix: [CONPORT_ACTIVE]/[CONPORT_INACTIVE]."
    - "If projectBrief.md found, read it; ask to import into product context."
    - "Proactive logging: suggest logging decisions/progress/context when appropriate; ask before logging."
    - "Error handling: on tool errors, log_custom_data(category:'ErrorLogs', key:'timestamp_error_summary', value: details); update active_context.open_issues if persistent."
    - "Semantic search: prefer when keywords insufficient; state why using it."
    - ⚠️ ConPort: Use lowercase relationship types ('implements' not 'IMPLEMENTS') or graph links won't display.

  # 3) Core routines (short checklists)
  conport_sync_routine:
    trigger: "^(Sync ConPort|ConPort Sync)$"
    user_ack: "[CONPORT_SYNCING]"
    do:
      - "Stop current activity; send [CONPORT_SYNCING]."
      - "Review chat for new info: decisions, progress, context changes, links."
      - "Log/Update accordingly (see tools below)."
      - "Optionally get_recent_activity_summary to confirm."
      - "Tell user sync complete; resume or await next task."

  dynamic_context_retrieval_for_rag:
    trigger: "Need specific project knowledge to answer/generate."
    priority_order: "Always prioritize targeted retrieval over broad scanning."
    steps:
      - "Analyze query: entities, terms, item types, specific IDs mentioned."
      - "PRIMARY - Direct fetch if IDs known: get_items_by_references with references:[{type,id}]."
      - "SECONDARY - Find IDs via FTS: search_decisions_fts, search_progress_fts, search_system_patterns_fts, search_custom_data_value_fts, search_project_glossary_fts, search_context_fts."
      - "TERTIARY - Targeted lists with strict limits: get_decisions(limit:3), get_progress(limit:3), get_system_patterns(limit:3), get_custom_data(category:specific)."
      - "EXPANSION - 1-hop neighborhood: get_linked_items on promising items → get_items_by_references with linked_items_result."
      - "FALLBACK - Broad context (last resort): get_product_context or get_active_context."
      - "SYNTHESIS - Filter irrelevant; synthesize concise summary; attribute sources."
      - "ASSEMBLY - Clear context separation from user query; keep token-efficient."

  proactive_knowledge_graph_linking:
    trigger: "Conversation implies relationships between ConPort items."
    steps:
      - "Monitor mentions of items (by ID/name) and implied relations."
      - "Detect strong candidates (e.g., decision → progress implements; pattern addresses decision concern)."
      - "Propose link with brief rationale; ask for confirmation + relationship type if needed (e.g., blocked_by, builds_on, clarifies, consumes, depends_on, derived_from, documented_in, implements, produces, related_to, resolves, tracks, verifies)."
      - "On confirm: ensure source/target types+IDs, agreed relationship; optional description; call link_conport_items."
      - "Confirm outcome to user."

  # 4) ConPort tools quick reference (keep MCP call specs intact; minimal prose)
  conport_updates:
    frequency: "Update during chat when significant changes occur or upon request."
    tools:
      - name: get_product_context
        when: "Need overall goals/features/architecture."
        call: "get_product_context({\"workspace_id\": \"...\"}) → dict"

      - name: update_product_context
        when: "Product description/goals/architecture changed."
        call: "update_product_context({\"workspace_id\":\"...\", \"content\":{...}}) or update_product_context({\"workspace_id\":\"...\", \"patch_content\":{key: value, to_remove: \"__DELETE__\"}})"

      - name: get_active_context
        when: "Need current task focus/goals/session state."
        call: "get_active_context({\"workspace_id\": \"...\"}) → dict"

      - name: update_active_context
        when: "Focus/goals/issue list changed."
        call: "update_active_context({\"workspace_id\":\"...\", \"content\":{...}}) or update_active_context({\"workspace_id\":\"...\", \"patch_content\":{key: value, to_delete: \"__DELETE__\"}})"

      - name: log_decision
        when: "Significant architectural/implementation decision confirmed."
        call: "log_decision({\"workspace_id\":\"...\", \"summary\":\"...\", \"rationale\":\"...\", \"implementation_details\":\"...\", \"tags\":[\"optional\"]})"
        note: "rationale, implementation_details, and tags are optional"

      - name: get_decisions
        when: "Review/find decisions."
        call: "get_decisions({\"workspace_id\":\"...\", \"limit\": N, \"tags_filter_include_all\":[\"...\"], \"tags_filter_include_any\":[\"...\"]})"

      - name: search_decisions_fts
        when: "Keyword search across decisions."
        call: "mcp0_search_decisions_fts({\"workspace_id\":\"...\", \"query_term\":\"...\", \"limit\": N})"

      - name: delete_decision_by_id
        when: "User confirms deletion by ID."
        call: "mcp0_delete_decision_by_id({\"workspace_id\":\"...\", \"decision_id\": ID})"

      - name: log_progress
        when: "Start/change/complete a task; create subtask."
        call: "log_progress({\"workspace_id\":\"...\", \"description\":\"...\", \"status\":\"...\", \"linked_item_type\":\"...\", \"linked_item_id\":\"...\"})"

      - name: get_progress
        when: "Review task statuses/history."
        call: "get_progress({\"workspace_id\":\"...\", \"status_filter\":\"...\", \"parent_id_filter\": ID, \"limit\": N})"

      - name: update_progress
        when: "Change an existing progress entry."
        call: "update_progress({\"workspace_id\":\"...\", \"progress_id\": ID, \"status\":\"...\", \"description\":\"...\", \"parent_id\": ID})"

      - name: delete_progress_by_id
        when: "Delete a progress entry (confirmed)."
        call: "mcp0_delete_progress_by_id({\"workspace_id\":\"...\", \"progress_id\": ID})"

      - name: log_system_pattern
        when: "Add/modify an architectural pattern."
        call: "log_system_pattern({\"workspace_id\":\"...\", \"name\":\"...\", \"description\":\"...\", \"tags\":[\"optional\"]})"

      - name: get_system_patterns
        when: "List patterns."
        call: "get_system_patterns({\"workspace_id\":\"...\", \"tags_filter_include_all\":[\"...\"], \"limit\": N})"

      - name: delete_system_pattern_by_id
        when: "Delete a pattern by ID (confirmed)."
        call: "mcp0_delete_system_pattern_by_id({\"workspace_id\":\"...\", \"pattern_id\": ID})"

      - name: log_custom_data
        when: "Store other context (glossary/specs/notes)."
        call: "log_custom_data({\"workspace_id\":\"...\", \"category\":\"...\", \"key\":\"...\", \"value\": any})"

      - name: get_custom_data
        when: "Retrieve custom data by category/key."
        call: "get_custom_data({\"workspace_id\":\"...\", \"category\":\"...\", \"key\":\"...\"})"

      - name: delete_custom_data
        when: "Delete custom data (confirmed)."
        call: "mcp0_delete_custom_data({\"workspace_id\":\"...\", \"category\":\"...\", \"key\":\"...\"})"

      - name: search_custom_data_value_fts
        when: "FTS across custom data values/categories/keys."
        call: "mcp0_search_custom_data_value_fts({\"workspace_id\":\"...\", \"query_term\":\"...\", \"category_filter\":\"...\", \"limit\": N})"

      - name: search_project_glossary_fts
        when: "Search within 'ProjectGlossary'."
        call: "mcp0_search_project_glossary_fts({\"workspace_id\":\"...\", \"query_term\":\"...\", \"limit\": N})"

      - name: semantic_search_conport
        when: "Conceptual query beyond keyword match."
        call: "mcp0_semantic_search_conport({\"workspace_id\":\"...\", \"query_text\":\"...\", \"top_k\": N, \"filter_item_types\":[\"decision\",\"custom_data\"]})"

      - name: link_conport_items
        when: "Link two existing items (e.g., implements/related_to/tracks/blocks/clarifies/depends_on/resolves/derived_from)."
        call: "mcp0_link_conport_items({\"workspace_id\":\"...\", \"source_item_type\":\"...\", \"source_item_id\":\"...\", \"target_item_type\":\"...\", \"target_item_id\":\"...\", \"relationship_type\":\"...\", \"description\":\"optional\"})"

      - name: get_linked_items
        when: "Explore relationships around an item."
        call: "mcp0_get_linked_items({\"workspace_id\":\"...\", \"item_type\":\"...\", \"item_id\":\"...\", \"relationship_type_filter\":\"...\", \"linked_item_type_filter\":\"...\", \"limit\": N})"

      - name: get_item_history
        when: "Review Product/Active Context versions or time-bounded changes."
        call: "mcp0_get_item_history({\"workspace_id\":\"...\", \"item_type\":\"product_context\"|\"active_context\", \"limit\": N, \"version\": V, \"before_timestamp\": \"ISO_DATETIME\", \"after_timestamp\": \"ISO_DATETIME\"})"

      - name: batch_log_items
        when: "User provides multiple items of same type to log at once."
        call: "mcp0_batch_log_items({\"workspace_id\":\"...\", \"item_type\":\"decision\"|\"system_pattern\"|\"custom_data\"|\"progress_entry\", \"items\":[{...}]})"

      - name: get_recent_activity_summary
        when: "Catch up on recent activities."
        call: "mcp0_get_recent_activity_summary({\"workspace_id\":\"...\", \"hours_ago\": H, \"since_timestamp\": \"ISO_DATETIME\", \"limit_per_type\": N})"

      - name: get_conport_schema
        when: "Uncertain about available tools/args, or user requests schema."
        call: "mcp0_get_conport_schema({\"workspace_id\":\"...\"})"

      - name: export_conport_to_markdown
        when: "Export to markdown (backup/sharing/version control)."
        call: "mcp0_export_conport_to_markdown({\"workspace_id\":\"...\", \"output_path\":\"optional/relative/path\"})"

      - name: import_markdown_to_conport
        when: "Import from exported markdown directory."
        call: "mcp0_import_markdown_to_conport({\"workspace_id\":\"...\", \"input_path\":\"optional/relative/path\"})"

      - name: launch_conport_ui
        when: "User requests UI launch or responds 'Yes, launch the UI'."
        call: "execute_command: 'python ./context_portal_aimed/portal_launcher.py'"
        note: "Launches MCP server (port 8020) + UI (port 3000). UI and chat tools sync on same DB."

      - name: search_progress_fts
        when: "FTS search in progress entries."
        call: "search_progress_fts({\"workspace_id\":\"...\", \"query_term\":\"...\", \"limit\": N})"

      - name: search_system_patterns_fts
        when: "FTS search in system patterns."
        call: "search_system_patterns_fts({\"workspace_id\":\"...\", \"query_term\":\"...\", \"limit\": N})"

      - name: search_context_fts
        when: "FTS search in product/active contexts."
        call: "search_context_fts({\"workspace_id\":\"...\", \"query_term\":\"...\", \"context_type_filter\":\"product|active\", \"limit\": N})"

      - name: update_link
        when: "Update existing link relationship/description."
        call: "update_link({\"workspace_id\":\"...\", \"link_id\": ID, \"relationship_type\":\"...\", \"description\":\"...\"})"

      - name: delete_link_by_id
        when: "Delete link by ID (confirmed)."
        call: "delete_link_by_id({\"workspace_id\":\"...\", \"link_id\": ID})"

      - name: get_items_by_references
        when: "Targeted retrieval by type/ID; 1-hop expansion from get_linked_items result."
        call: "get_items_by_references({\"workspace_id\":\"...\", \"references\":[{\"type\":\"progress_entry\",\"id\":\"22\"}]}) OR get_items_by_references({\"workspace_id\":\"...\", \"linked_items_result\":[...]})"